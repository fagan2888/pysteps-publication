'''
Script ot plot the temporal autocorrelation functions (ACF) of nowcasts and observations 
that were previously generated by the script run_ar_correlation_tests_cascade.py.
The script also derives the lifetimes and plots them against the spatial scale.
'''

import pickle
from matplotlib import pyplot
from matplotlib.pyplot import cm
import numpy as np
from pysteps.verification.lifetime import lifetime

# the domain: "fmi" or "mch_hdf5"
domain          = "mch_hdf5"
n_levels_verif  = [1,8]
recompute_flow  = False
max_leadtime_min = 5000 # for plotting the ACFs
rule = '1/e' # Rule to integrate the ACF and get the lifetime [1/e, trapz]

##
results_cascade = {}
for n_levels in n_levels_verif:
    filename = "data/%s_ar2_corr_results_%ilevels_recomputeflow-%s_allcases.dat" % (domain,n_levels,recompute_flow)
    with open(filename, "rb") as f:
        results = pickle.load(f)
    print(filename, "read.")
    results_cascade[n_levels] = results
    
    num_cascade_levels = len(results["cc_obs"]) 
    leadtimes = results["leadtimes"]
    leadtimes_plot = leadtimes[0:int(max_leadtime_min/results["timestep"])]
    
    fig = pyplot.figure(figsize=(5, 3.75))
    ax = fig.gca()

    colors=iter(cm.Blues_r(np.linspace(0,1,num_cascade_levels+2)))
    for i in range(num_cascade_levels):
        # Derive average ACF for sufficient number of time stamps
        acf_fct = results["cc_fct"][i] / results["n_fct_samples"][i]
        acf_obs = results["cc_obs"][i] / results["n_obs_samples"][i]
        
        # Plot
        col = next(colors)
        ax.plot(leadtimes_plot, acf_fct[0:len(leadtimes_plot)], color=col, linestyle="--")
        ax.plot(leadtimes_plot, acf_obs[0:len(leadtimes_plot)], color=col)

    lines = ax.get_lines()
    l = pyplot.legend([lines[0], lines[1]], ["Forecasts", "Observations"],
                      fontsize=12, loc=(0.6, 0.92), framealpha=1.0)
    ax.add_artist(l)

    colors=iter(cm.Blues_r(np.linspace(0,1,num_cascade_levels+2)))
    max_leadtime = np.max(leadtimes_plot)
    ax.text(150.0/150*max_leadtime, 0.85, '1', fontsize=10, color=next(colors))
    ax.text(139.0/150*max_leadtime, 0.71, '2', fontsize=10, color=next(colors))
    ax.text(120.0/150*max_leadtime, 0.35, '3', fontsize=10, color=next(colors))
    ax.text(93.0/150*max_leadtime, 0.18, '4', fontsize=10, color=next(colors))
    ax.text(75.0/150*max_leadtime, 0.07, '5', fontsize=10, color=next(colors))
    ax.text(38.0/150*max_leadtime, 0.05, '6', fontsize=10, color=next(colors))
    ax.text(15.0/150*max_leadtime, 0.05, '7', fontsize=10, color=next(colors))
    ax.text(7.0/150*max_leadtime, 0.021, '8', fontsize=10, color=next(colors))
    
    if max_leadtime_min < 500:
        tick_spacing = 20
    elif max_leadtime_min < 2000:
        tick_spacing = 60
    else:
        tick_spacing = 480
        
    xt = np.hstack([[5], np.arange(0, np.max(leadtimes_plot)+5, tick_spacing)])
    ax.set_xticks(xt)
    ax.set_xticklabels([int(v) for v in xt])
    ax.tick_params(labelsize=10)

    pyplot.grid(True)

    pyplot.xlim(leadtimes_plot[0], leadtimes_plot[-1])
    pyplot.ylim(-0.02, 1.1)

    pyplot.xlabel("Lead time (minutes)", fontsize=12)
    pyplot.ylabel("Correlation", fontsize=12)

    figname = "figures/%s_ar2_correlations_%ilevels_recomputeflow-%s.pdf" % (domain,n_levels,recompute_flow)
    pyplot.savefig(figname, bbox_inches="tight")
    print(figname, 'saved.')

## Estimate lifetimes from ACF
lifetime_array = []
for i in range(num_cascade_levels):
    # Lifetime of observations
    acf_obs = results["cc_obs"][i] / results["n_obs_samples"][i]
    lf_obs = lifetime(acf_obs, leadtimes, rule=rule)
    
    # Lifetime fo forecasts
    lf_all = [lf_obs]
    for lev in n_levels_verif:
        acf_fct = results_cascade[lev]["cc_fct"][i] / results_cascade[lev]["n_fct_samples"][i]
        lf_fx = lifetime(acf_fct, leadtimes, rule=rule)
        lf_all.append(lf_fx)
    
    lifetime_array.append(lf_all)
lifetime_array = np.array(lifetime_array)

# Plot log(wavelength) vs log(lifetime), i.e. the dynamic scaling plot
fig = pyplot.figure(figsize=(5, 3.75))
ax = fig.gca()

pyplot.loglog(results["central_wavelengths"], lifetime_array[:,0], "k", label="Observations")

linestyles = ["k--", "k:", "k-."]
for idx,lev in enumerate(n_levels_verif):
    if lev == 1:
        lab_txt = "Forecasts 1-level"
    else:
        lab_txt = "Forecasts %i-levels" % lev
    pyplot.loglog(results["central_wavelengths"], lifetime_array[:,idx+1], linestyles[idx], label=lab_txt)

# Decorate plot
pyplot.xlabel("Wavelength [km]", fontsize=12)
pyplot.ylabel("Lifetime [min]", fontsize=12)
pyplot.legend(loc="lower right")
pyplot.grid()

rule_txt = "e" if rule == "1/e" else rule
figname = "figures/%s_ar2_wavelength-vs-lifetime_rule-%s_recomputeflow-%s.pdf" % (domain,rule_txt,recompute_flow)
pyplot.savefig(figname, bbox_inches="tight")
print(figname, 'saved.')