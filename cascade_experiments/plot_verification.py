#!/bin/env python

"""
Cascade verification plots:
The script reads the file generated by run_nowcast_verification.py and plots
verification results for different lead times and rainfall thresholds.
"""

from mpl_toolkits.axes_grid1.inset_locator import inset_axes
from pylab import *
import pickle
from pysteps.verification import ensscores, probscores

# Parameters
filename_verif = "data/cascade_results_rainrate.dat"

fixedleadtimes = [5,11] # timesteps for rainrate
#fixedleadtimes = [0] # timesteps for 60 min accum
minmaxleadtimes = [5, 90] # min
R_thrs = [0.1, 1.0, 5.0, 10.0]

# Plot parameters
basename_figs = "cascade"
fmt = "pdf"
ftsize_title = 16
linecolors = ["C3", "C0", "C1", "C2", "C4", "C5", "C6"]
linestyles = ['-', '-', '-', '-', '-']
markers = ['o', 'o', 'o', 'o', 'o']

with open(filename_verif, "rb") as f:
    results = pickle.load(f)
    print(f, 'read.')
    
    # Get metadata on accumulation
    if "metadata" in results:
        verify_accumulation = results["metadata"]["accumulation"]
        v_accu = results["metadata"]["v_accu"]
        del results["metadata"]
    else:
        v_accu = 5
    
    # Get keys of experiments (without metadata)
    results_keys = results.keys()
    print("Available experiments:\n", list(results_keys))
    
    # Get number of lead times
    for i,exp in enumerate(results_keys):
        c = exp[0]
        m = exp[1]
        n_lead_times = len(results[c,m]["ROC"][R_thrs[0]])
        # Adapt size of array fixedleadtimes
        fixedleadtimes_ = np.array(fixedleadtimes)
        fixedleadtimes_ = fixedleadtimes_[fixedleadtimes_ < n_lead_times]
        fixedleadtimes = fixedleadtimes_.tolist()
        break
    
for R_thr in R_thrs:
        
    # ROC curves
    for lt in fixedleadtimes:

        figure()

        plot([0, 1], [0, 1], "k--")
        
        i=0
        for i,exp in enumerate(results_keys):
            c = exp[0]
            m = exp[1]
            m_str = "-" if m == None else "+"
            ROC = results[c,m]["ROC"][R_thr][lt]
            POFD,POD,area = probscores.ROC_curve_compute(ROC, compute_area=True)
            plot(POFD, POD, color=linecolors[i], linestyle='-', marker='D', 
                 label="%i levels %s mask (area=%.3f)" % (c, m_str, area))

        xlim(0, 1)
        ylim(0, 1)
        xlabel("False alarm rate (POFD)")
        ylabel("Probability of detection (POD)")
        title("ROC curves +%i min R > %.1f mm/h" % ((lt+1)*v_accu, R_thr), fontsize=ftsize_title)
        title("ROC curves for R > %.1f mm/h" % (R_thr), fontsize=ftsize_title)
        grid(True, ls=':')
        legend(fontsize=12)
        
        figname = "figures/%s_ROC_curves_accu%02i_%dmin_%03.1fmm.%s" % (basename_figs, v_accu, (lt+1)*v_accu, R_thr, fmt)
        savefig(figname, bbox_inches="tight")
        print(figname, "saved.")
        
    # Reliability diagrams
    for lt in fixedleadtimes:
        fig = figure()
        ax = fig.gca()
        iax = inset_axes(ax, width="35%", height="20%", loc=4, borderpad=3.5)

        sample_size_min = []
        sample_size_max = []

        for i,exp in enumerate(results_keys):
            c = exp[0]
            m = exp[1]
            m_str = "-" if m == None else "+"
            reldiag = results[c,m]["reldiag"][R_thr][lt]

            f = 1.0 * reldiag["Y_sum"] / reldiag["num_idx"]
            r = 1.0 * reldiag["X_sum"] / reldiag["num_idx"]

            mask = np.logical_and(np.isfinite(r), np.isfinite(f))
            
            # Plot reliability
            ax.plot(r[mask], f[mask], color=linecolors[i], linestyle='-', marker='D', 
                    label="%i levels %s mask" % (c, m_str))

            # Plot sharpness diagram
            bd = 0.5 * (reldiag["bin_edges"][1] - reldiag["bin_edges"][0])
            iax.plot(reldiag["bin_edges"][:-1] + bd, reldiag["sample_size"], 
                     color=linecolors[i], linestyle='-', marker='D', ms=3)

            sample_size_min.append(int(max(floor(log10(min(reldiag["sample_size"]))), 1)))
            sample_size_max.append(int(ceil(log10(max(reldiag["sample_size"])))))

        iax.set_yscale("log", basey=10)
        iax.set_xticks(reldiag["bin_edges"])
        iax.set_xticklabels(["%.1f" % max(v, 1e-6) for v in reldiag["bin_edges"]])
        yt_min = min(sample_size_min)
        yt_max = max(sample_size_max)
        t = [pow(10.0, k) for k in range(yt_min, yt_max)]
        iax.set_yticks([int(t_) for t_ in t])
        iax.set_xlim(0.0, 1.0)
        iax.set_ylim(0.5*t[0], 5*t[-1])
        iax.set_ylabel("$\log_{10}$(samples)")
        iax.yaxis.tick_right()
        iax.yaxis.set_label_position("right")
        iax.tick_params(axis="both", which="major", labelsize=6)
        iax.grid(axis='y', ls=':')

        ax.plot([0, 1], [0, 1], "k--")
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.grid(True, ls=':')
        ax.legend(fontsize=12)
        ax.set_xlabel("Forecast probability")
        ax.set_ylabel("Observed relative frequency")
        ax.set_title("Reliability for R > %.1f mm/h" % (R_thr), fontsize=ftsize_title)
        
        figname = "figures/%s_reldiags_accu%02i_%dmin_%03.1fmm.%s" % (basename_figs, v_accu, (lt+1)*v_accu, R_thr, fmt)
        savefig(figname, bbox_inches="tight")
        print(figname, "saved.")
        
    # Rank hist
    for lt in fixedleadtimes:
        figure()

        r_max = 0.0
        for i,exp in enumerate(results_keys):
            c = exp[0]
            m = exp[1]
            m_str = "-" if m == None else "+"
            rankhist = results[c,m]["rankhist"][R_thr][lt]
            r = ensscores.rankhist_compute(rankhist)
            r_max = max(r_max, np.max(r))
            x = np.linspace(0, 1, rankhist["num_ens_members"] + 1)
            x += 0.5 * (x[1] - x[0])
            plot(x, r, color=linecolors[i], linestyle='-', marker='D', 
                 label="%i levels %s mask" % (c, m_str))
                 
        plot(x, np.ones_like(x)*1/x.size, "k--", lw=0.8)

        xticks(x[::3] + (x[1] - x[0]), np.arange(1, len(x))[::3])
        xlim(0, 1+1.0/len(x))
        ylim(0, r_max*1.25)
        xlabel("Rank of observation (among ensemble members)")
        ylabel("Relative frequency")
        title("Rank histograms", fontsize=ftsize_title)
        grid(True, axis='y', ls=':')
        legend(fontsize=12)
        
        figname = "figures/%s_rankhists_accu%02i_%dmin_%03.1fmm.%s" % (basename_figs, v_accu, (lt+1)*v_accu, R_thr, fmt)
        savefig(figname, bbox_inches="tight")
        print(figname, "saved.")
        
    # ROC areas
    ROC_areas = dict([(exp, []) for exp in results_keys])
    OPs = dict([(exp, []) for exp in results_keys])

    for i,exp in enumerate(results_keys):
        c = exp[0]
        m = exp[1]
        m_str = "-" if m == None else "+"
        if not exp in ROC_areas.keys():
            ROC_areas[exp] = []
        for lt in sorted(results[c,m]["ROC"][R_thr].keys()):
            a = probscores.ROC_curve_compute(results[c,m]["ROC"][R_thr][lt], compute_area=True)[2]
            ROC_areas[exp].append(a)
        for lt in sorted(results[c,m]["rankhist"][R_thr].keys()):
            rh = ensscores.rankhist_compute(results[c,m]["rankhist"][R_thr][lt])
            OP = (rh[0] + rh[-1]) / sum(rh)
            OPs[c,m].append(OP) 

    fig = figure()
    ax = fig.gca()
    for i,exp in enumerate(ROC_areas.keys()):
        c = exp[0]
        m = exp[1]
        m_str = "-" if m == None else "+"
        leadtimes = (arange(len(ROC_areas[c,m])) + 1) * 5
        ax.plot(leadtimes, ROC_areas[exp], ls=linestyles[i], marker=markers[i], 
                color=linecolors[i], label="%i levels %s mask" % (c, m_str), lw=2, ms=6)
    ax.set_xlim(minmaxleadtimes[0], minmaxleadtimes[1])
    # ax.set_ylim(0.82, 0.98)
    ax.grid(True)
    ax.legend(fontsize=12)
    ax.set_xlabel("Lead time (minutes)", fontsize=12)
    ax.set_ylabel("ROC area", fontsize=12)
    title("ROC area for R > %.1f mm/h" % (R_thr), fontsize=ftsize_title)
    
    figname = "figures/%s_ROC_areas_accu%02i_%03.1fmm.%s" % (basename_figs, v_accu, R_thr, fmt)
    fig.savefig(figname, bbox_inches="tight")
    print(figname, 'saved.')

    # Outlier proportion (OP)
    fig = figure()
    ax = fig.gca()
    for i,exp in enumerate(results_keys):
        c = exp[0]
        m = exp[1]
        m_str = "-" if m == None else "+"
        leadtimes = (arange(len(OPs[c,m])) + 1) * 5
        ax.plot(leadtimes, OPs[c,m], ls=linestyles[i], marker=markers[i], 
                color=linecolors[i], label="%i levels %s mask" % (c, m_str), lw=2, ms=6)
    ax.plot(leadtimes, np.ones(len(leadtimes))*(2.0/(rankhist["num_ens_members"] + 1)), 'k--')
    ax.set_xlim(minmaxleadtimes[0], minmaxleadtimes[1])
    # ax.set_ylim(0.01, 0.675)
    ax.grid(True)
    ax.legend(fontsize=12)
    ax.set_xlabel("Lead time (minutes)", fontsize=12)
    ax.set_ylabel("Percentage of outliers", fontsize=12)
    title("Outlier proportion for R > %.1f mm/h" % (R_thr), fontsize=ftsize_title)
    
    figname = "figures/%s_OPs_accu%02i_%03.1fmm.%s" % (basename_figs, v_accu, R_thr, fmt)
    fig.savefig(figname, bbox_inches="tight")
    print(figname, 'saved.')
    print('---------------')
